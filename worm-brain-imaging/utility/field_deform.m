function varargout = field_deform(input, u, varargin)
% output = field_deform(input, u, varargin)
%
%  deforms the input according to the vectors specified by u.  
%  If u is an Mx2 cell array of 3-tuples, those pairs are used 
%  to generate the deformation field.
%
% [output, u] = field_deform(input, u, varargin)
%
%  additionally returns the deformation field used (either u or the field
%  generated by the list of points in d)
%
% This process should preserve the normalization of the image (except near
% the edges)

siz = size(input);

default_options = struct(...
                        'direction', 1, ...
                        'fraction_to_warp', 0.2 ...
                        );
input_options = varargin2struct(varargin{:}); 
options = mergestruct(default_options, input_options);

threshold = quantile(row(input), 1-options.fraction_to_warp);

% handle the case where u is a set of reference points
if size(u,2) == 2
    disp('making u');
    u = field_from_displacements(u, size(input));
    disp('done');
end

output = zeros(size(input), class(input));
disp('warping');
for i = 1:numel(input)
    
    [old_y, old_x, old_z] = ind2sub(siz,i);
    old_coords = [old_y, old_x, old_z];
    old_val = input(i);
    
    if old_val > threshold
        new_coords = old_coords + options.direction*row(u{i});

        new_coords_whole = floor(new_coords);
        new_coords_frac = mod(new_coords, 1);

        % proportionally smear the new data over a 2^N hyperpixel 
        % to ensure the result looks good while preserving intensity
        for j = 1 : 8
            [iy, ix, iz] = ind2sub([2 2 2], j);
            idx = [iy, ix, iz];
            idx = idx - 1; % 0-indexed coords

            weight = prod(new_coords_frac.^(idx) .* ...
                          (1-new_coords_frac).^(1-idx));

            new_val = weight * old_val;

            idx = new_coords_whole + idx;

            if all(idx>=1) && all(idx<=siz)
               output(idx(1), idx(2), idx(3)) = ...
                   output(idx(1), idx(2), idx(3)) + new_val;
            end

        end
    end
end
disp('done');

varargout{1} = output;
varargout{2} = u;